# huibian_HM3

*学号：2015011340 姓名：骆轩源

#我的算法优化了两个地方：
1.向系统调用brk的操作数目为O(log(n))，其中n为最终堆占用的内存空间总长度。 由于n <= 内存总大小，假设内存为8G，那么调用次数不超过33。
2.合并了相邻的空白块。

#实现方法：
1.优化系统调用的方法是，记录最近一次向系统申请增加的堆的长度的大小，记为current_size，假设遇到了一个新的allocate请求空间为asked_size,并且
  当前没有空白块可以放下，那么就将堆的长度扩大max(current_size * 2,asked_size)，可以证明，第i次申请的大小至少为2^i。故证明了系统调用次数为
  O(log n)级别。 

2.空白区域的合并，是每一次释放操作时，从头到尾扫描合并。

#实验准备：
1.实验代码：alloc.s, newalloc.s, alloc_with_clear.s
	其中alloc.s是ppt上的代码，每一次扩展是直接扩展所需空间，也不做合并相邻空白块的优化。
	   newalloc.s是加上了按2的幂扩展的优化，减少了系统调用。
	   alloc_with_clear.s是同时加上了空白块合并优化，以及2的幂优化。
	   
2.测试代码：mkdata.py,test.s

其中mkdata.py用来生成测试代码，测试代码中，首先输出当前break位置，然后运行n条指令，n条指令为随机生成的alloc和dealloc指令，为了在dealloc操作时
知道需要释放的位置，需要用一个很大的栈记录每一次alloc后返回的eax，我是按照对应编号存的，第i个alloc指令的返回结果，被存到了栈的4*i(%ebp)。

设置好mkdata.py，运行`python mkdata.py`，就会生成test.s，这时只需要分别运行：

*`bash run.sh`  //该指令测试alloc.s中实现的代码
*`bash run2.sh` //该指令测试alloc_with_clear.s中实现的代码
*`bash run3.sh` //该指令测试newalloc.s中实现的代码

#实验1（系统调用优化）：

本实验中，mkdata.py只生成500000条 alloc指令，返回地址也不存储到栈（随便存到了4(%ebp)），参与对比的代码是alloc.s和newalloc.s

快速的使用方法为，将test1.s重命名为test.s之后，执行run.sh和run3.sh即可

对于alloc.s的返回结果为(run.sh)：
	root@f42aaf989e67:/home/huibian_HM3# time ./test
	brk(0):164945920
	brk(0):169445920

	real	5m17.765s
	user	5m17.468s
	sys	0m0.244s
对于newalloc.s的返回结果为(run3.sh)：
	root@f42aaf989e67:/home/huibian_HM3# time ./test3
	brk(0):145268736
	brk(0):153657527

	real	5m1.659s
	user	5m1.632s
	sys	0m0.032s
可以看到减少系统调用之后，时间确实有减少。

相比之下，newalloc.s没有优化每一次O(n)的遍历每个块，故总时间都是5分钟左右，但是因为优化了系统的调用，所以少了16秒左右。
#实验2（合并空白优化：）

本实验中，mkdata.py中生成100条alloc和dealloc指令，其中生成alloc指令的概率为20%，每次申请的大小是取自[1,200]的随机数，dealloc是随机从当前
还没有没释放的块中选择一块。

快速的使用方法为，将test2.s重命名为test.s之后，执行run2.sh和run3.sh即可

对于alloc_with_free.s的返回结果为(run2.sh):
	root@f42aaf989e67:/home/huibian_HM3# ./test2
	brk(0):152702976
	brk(0):152703728

得到一共扩展的堆空间为：152703728 - 152702976 = 752

对于newalloc.s的返回结果为(run3.sh):
	root@f42aaf989e67:/home/huibian_HM3# ./test3
	brk(0):136527872
	brk(0):136529464
得到一共扩展的堆空间为：136529464 - 136527872 = 1592

本实验中设置alloc指令的概率远比dealloc小是为了尽量产生位置相邻的空块，让效果更加明显，从结果来看，优化效果显著。

#一些思考：
1.对于作业要求的第一个，优化O(n)的访问，看过一些方法，比如将块的大小分成若干类，然后对于每一类，建立一个链表可以节约一些时间，但是本质没有变化，
  倘若alloc的大小都差不多，那么其实本质没有优化，真正要优化到O(n)以下，除非设计一个数据结构才可以，故没有实现。

2.对于第2个优化系统调用次数，我认为page_size并没有什么理论保证，故实现的是按照递增的2的幂来申请空间，这样的系统调用时间减少了，但是仅仅看系统调用次数
  是没有意义的，考虑一次性调用全部的空间，这样系统调用就只有一次，但是浪费了很多空间。
  
  按照2的幂，可以保证浪费的空间不超过O(n)，其中n为最终内存空间中最后一个被利用的位置。这是因为，假设最后一次申请空间是第k次，那么有：
  2^(k - 1) <= n <= 2^k，所以浪费的空间 <= 2^k - 2^(k - 1) = 2^(k - 1)。
  
  还可以每一次申请不翻倍，只加1，那么就有至多O(sqrt(n))次系统调用，浪费的空间最多为O(sqrt(n))，这是因为，假设最后一次调用申请的空间是第k次，那么有：
  k(k + 1) /2 <= n <= (k + 1)(k + 2)/2 ，浪费的空间 <= (k + 1)(k + 2)/ 2 - k(k + 1) / 2 = k + 1。 而k = O(sqrt(n))。
  
  所以可以看到，当希望时间少的时候，空间就会多，二者很难兼得，sqrt(n)就是一个很好的平衡。

3.当涉及到需要dealloc的实验的时候，由于需要一个栈来记录已经alloc的请求的位置，所以数据做不了太大，也很难看出效率差别，所以在合并空白块的时候，采用的暴力
  做法，只是为了查看空间的优化效果。
  

